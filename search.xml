<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>class总结</title>
      <link href="2020/12/28/class%E6%80%BB%E7%BB%93/"/>
      <url>2020/12/28/class%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>什么是class？、<br>他是怎么来的？<br>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><p>function Point(x, y) {<br>  this.x = x;<br>  this.y = y;<br>}<br>Point.prototype.toString = function () {<br>  return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>};<br>var p = new Point(1, 2);<br>这种写法跟传统的面向对象语言比如 C++ 和 Java差异很是大的</p><p>上面的代码用es6改写的class写法如下<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }</p><p>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }<br>}</p><p>上面代码定义了一个“类”，可以看到里面有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数Point是一致的。</p><p>Point类除了构造方法，还定义了一个toString()方法。注意，定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。<br>class Point {<br>  // …<br>}<br>typeof Point // “function”<br>Point === Point.prototype.constructor // true<br>类的数据类型就是函数，类本身就指向构造函数。使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br>class Bar {<br>  doStuff() {<br>    console.log(‘stuff’);<br>  }<br>}<br>const b = new Bar();<br>b.doStuff() // “stuff”<br>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br>class Point {<br>  constructor() {<br>    // …<br>  }</p><p>  toString() {<br>    // …<br>  }</p><p>  toValue() {<br>    // …<br>  }<br>}<br>// 等同于<br>Point.prototype = {<br>  constructor() {},<br>  toString() {},<br>  toValue() {},<br>};</p><p>因此，在类的实例上面调用方法，其实就是调用原型上的方法。<br>class B {}<br>const b = new B();</p><p>b.constructor === B.prototype.constructor // true<br>b是B类的实例，它的constructor()方法就是B类原型的constructor()方法。</p><p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类添加多个方法。<br>class Point {<br>  constructor(){<br>    // …<br>  }<br>}</p><p>Object.assign(Point.prototype, {<br>  toString(){},<br>  toValue(){}<br>});<br>prototype对象的constructor()属性，直接指向“类”的本身，这与 ES5 的行为是一致的。<br>Point.prototype.constructor === Point // true</p><p>constructor 方法<br>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p><p>class Point {<br>}</p><p>// 等同于<br>class Point {<br>  constructor() {}<br>}</p><p>类的实例<br>生成类的实例的写法，与 ES5 完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p><p>class Point {<br>  // …<br>}</p><p>// 报错<br>var point = Point(2, 3);</p><p>// 正确<br>var point = new Point(2, 3);</p><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p><p>//定义类<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }<br>}<br>var point = new Point(2, 3);<br>point.toString() // (2, 3)<br>point.hasOwnProperty(‘x’) // true<br>point.hasOwnProperty(‘y’) // true<br>point.hasOwnProperty(‘toString’) // false<br>point.<strong>proto</strong>.hasOwnProperty(‘toString’) // true</p><p>与 ES5 一样，类的所有实例共享一个原型对象。<br>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p><p>p1.<strong>proto</strong> === p2.<strong>proto</strong><br>//true<br>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。</p><p>这也意味着，可以通过实例的__proto__属性为“类”添加方法。</p><p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p><p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p><p>p1.<strong>proto</strong>.printName = function () { return ‘Oops’ };</p><p>p1.printName() // “Oops”<br>p2.printName() // “Oops”</p><p>var p3 = new Point(4,2);<br>p3.printName() // “Oops”<br>上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。<br>取值函数（getter）和存值函数（setter）<br>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><p>class MyClass {<br>  constructor() {<br>    // …<br>  }<br>  get prop() {<br>    return ‘getter’;<br>  }<br>  set prop(value) {<br>    console.log(‘setter: ‘+value);<br>  }<br>}</p><p>let inst = new MyClass();</p><p>inst.prop = 123;<br>// setter: 123</p><p>inst.prop<br>// ‘getter’</p><p>属性表达式<br>类的属性名，可以采用表达式。</p><p>let methodName = ‘getArea’;</p><p>class Square {<br>  constructor(length) {<br>    // …<br>  }</p><p>  <a href="">methodName</a> {<br>    // …<br>  }<br>}<br>Square类的方法名getArea，是从表达式得到的。</p><p>Class 表达式<br>与函数一样，类也可以使用表达式的形式定义。</p><p>const MyClass = class Me {<br>  getClassName() {<br>    return Me.name;<br>  }<br>};<br>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。</p><p>采用 Class 表达式，可以写出立即执行的 Class。</p><p>let person = new class {<br>  constructor(name) {<br>    this.name = name;<br>  }</p><p>  sayName() {<br>    console.log(this.name);<br>  }<br>}(‘张三’);</p><p>person.sayName(); // “张三” person是一个立即执行的类的实例</p><p>静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p><p>Foo.classMethod() // ‘hello’</p><p>var foo = new Foo();<br>foo.classMethod()<br>// TypeError: foo.classMethod is not a function<br>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。</p><p>class Foo {<br>  static bar() {<br>    this.baz();<br>  }<br>  static baz() {<br>    console.log(‘hello’);<br>  }<br>  baz() {<br>    console.log(‘world’);<br>  }<br>}</p><p>Foo.bar() // hello<br>上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p>父类的静态方法，可以被子类继承。</p><p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p><p>class Bar extends Foo {<br>}</p><p>Bar.classMethod() // ‘hello’<br>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p><p>静态方法也是可以从super对象上调用的。</p><p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p><p>class Bar extends Foo {<br>  static classMethod() {<br>    return super.classMethod() + ‘, too’;<br>  }<br>}</p><p>Bar.classMethod() // “hello, too”<br>实例属性的新写法<br>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><p>class IncreasingCounter {<br>  constructor() {<br>    this._count = 0;<br>  }<br>  get value() {<br>    console.log(‘Getting the current value!’);<br>    return this._count;<br>  }<br>  increment() {<br>    this._count++;<br>  }<br>}<br>上面代码中，实例属性this._count定义在constructor()方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。</p><p>class IncreasingCounter {<br>  _count = 0;<br>  get value() {<br>    console.log(‘Getting the current value!’);<br>    return this._count;<br>  }<br>  increment() {<br>    this._count++;<br>  }<br>}<br>上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。这时，不需要在实例属性前面加上this。</p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p><p>class foo {<br>  bar = ‘hello’;<br>  baz = ‘world’;</p><p>  constructor() {<br>    // …<br>  }<br>}<br>上面的代码，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><p>静态属性<br>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p><p>class Foo {<br>}</p><p>Foo.prop = 1;<br>Foo.prop // 1<br>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。</p><p>class MyClass {<br>  static myStaticProp = 42;</p><p>  constructor() {<br>    console.log(MyClass.myStaticProp); // 42<br>  }<br>}<br>这个新写法大大方便了静态属性的表达。</p><p>// 老写法<br>class Foo {<br>  // …<br>}<br>Foo.prop = 1;</p><p>// 新写法<br>class Foo {<br>  static prop = 1;<br>}<br>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hooks总结</title>
      <link href="2020/12/25/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/12/25/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>大部分 React 类组件可以保存状态，而函数组件不能？ 并且类组件具有生命周期，而函数组件却不能？<br>React 早期版本，类组件可以通过继承PureComponent来优化一些不必要的渲染，相对于函数组件，React 官网没有提供对应的方法来缓存函数组件以减少一些不必要的渲染，直接 16.6 出来的 React.memo函数。</p><p>React 16.8 新出来的Hook可以让React 函数组件具有状态，并提供类似 componentDidMount和componentDidUpdate,componentunMount等生命周期方法。</p><p>类被会替代吗？<br>Hooks不会替换类，它们只是一个你可以使用的新工具。React 团队表示他们没有计划在React中弃用类，所以如果你想继续使用它们，可以继续用。<br>基础的Hook目前有三个先介绍一下</p><p>1:useState 2:useEffect 3:useContext</p><p>useState<br>语法 const [state, setState] = useState(initialState);<br>返回一个state，以及更新state的函数 Hook 简介章节中使用下面的例子介绍了 Hook：</p><p>import React, { useState } from ‘react’;</p><p>function Example() {<br>  // 声明一个叫 “count” 的 state 变量<br>  const [count, setCount] = useState(0);<br>  return (<br>    <div><br>      <p>{count}</p><br>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br>        改变count值+=1<br>      </button><br>    </div><br>  );<br>}</p><p>这段代码的大部分看起来像一分钟前写的普通函数组件，除了useState。<br>useState是一个hook。 它的名字以“use”开头（这是Hooks的规则之一 - 它们的名字必须以“use”开头）。<br>useState hook 的参数是 state 的初始值，返回一个包含两个元素的数组:当前state和一个用于更改state 的函数。<br>由于Hook以某种特殊方式创建这些状态，并且在函数组件内也没有像setState函数来更改状态，因此 Hook 需要一个函数来更新每个状态。 所以 useState 返回是一对对应关系：一个值，一个更新该值函数。 当然，值可以是任何东西 - 任何JS类型 - 数字，布尔值，对象，数组等。<br>等价的 class 示例</p><p>class Example extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>  render() {<br>    return (<br>      <div><br>        <p>{this.state.count}</p><br>        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;<br>        改变count值+=1<br>        </button><br>      </div><br>    );<br>  }<br>}<br>useEffect<br>useEffect(didUpdate);<br>该 Hook 接收一个包含命令式、且可能有副作用代码的函数。</p><p>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p><p>使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p><p>默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。</p><p>清除 effect<br>通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个创建订阅的例子：</p><p>useEffect(() =&gt; {<br>  const subscription = props.source.subscribe();<br>  return () =&gt; {<br>    // 清除订阅<br>    subscription.unsubscribe();<br>  };<br>});<br>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都触发 effect 的执行，请参阅下一小节。<br>effect 的执行时机<br>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p><p>然而，并非所有 effect 都可以被延迟执行。例如，在浏览器执行下一次绘制前，用户可见的 DOM 变更就必须同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。</p><p>虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p><p>effect 的条件执行<br>默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。</p><p>然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 source prop 改变时重新创建。</p><p>要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下：</p><p>useEffect(<br>  () =&gt; {<br>    const subscription = props.source.subscribe();<br>    return () =&gt; {<br>      subscription.unsubscribe();<br>    };<br>  },<br>  [props.source],<br>);<br>此时，只有当 props.source 改变后才会重新创建订阅。</p><p>依赖项数组不会作为参数传给 effect 函数。虽然从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p><p>useContext<br>const value = useContext(MyContext);<br>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</p><p>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。</p><p>别忘记 useContext 的参数必须是 context 对象本身：</p><p>正确： useContext(MyContext)<br>错误： useContext(MyContext.Consumer)<br>错误： useContext(MyContext.Provider)<br>调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 通过使用 memoization 来优化。</p><p>useReducer<br>const [state, dispatch] = useReducer(reducer, initialArg, init);<br>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。<br>指定初始 state<br>有两种不同初始化 useReducer state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法：<br>惰性初始化<br>你可以选择惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。</p><p>这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：<br>跳过 dispatch<br>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。</p><p>useCallback<br>返回一个 memoized 回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。<br>useMemo<br>返回一个 memoized 值。</p><p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p><p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</p><p>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。<br>useRef<br>const refContainer = useRef(initialValue);<br>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>一个常见的用例便是命令式地访问子组件：</p><p>function TextInputWithFocusButton() {<br>  const inputEl = useRef(null);<br>  const onButtonClick = () =&gt; {<br>    // <code>current</code> 指向已挂载到 DOM 上的文本输入元素<br>    inputEl.current.focus();<br>  };<br>  return (<br>    &lt;&gt;<br>      <input ref={inputEl} type="text" /><br>      <button onClick={onButtonClick}>Focus the input</button><br>    &lt;/&gt;<br>  );<br>}<br>本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。</p><p>你应该熟悉 ref 这一种访问 DOM 的主要方式。如果你将 ref 对象以 <div ref={myRef} /> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。</p><p>然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。</p><p>这是因为它创建的是一个普通 Javascript 对象。而 useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。</p><p>请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p><p>useImperativeHandle<br>useImperativeHandle(ref, createHandle, [deps])<br>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用：</p><p>function FancyInput(props, ref) {<br>  const inputRef = useRef();<br>  useImperativeHandle(ref, () =&gt; ({<br>    focus: () =&gt; {<br>      inputRef.current.focus();<br>    }<br>  }));<br>  return &lt;input ref={inputRef} … /&gt;;<br>}<br>FancyInput = forwardRef(FancyInput);<br>在本例中，渲染 <FancyInput ref={inputRef} /> 的父组件可以调用 inputRef.current.focus()。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="2020/12/25/test/"/>
      <url>2020/12/25/test/</url>
      
        <content type="html"><![CDATA[<p>hexo clean<br>hexo generate<br>hexo deploy</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/25/hello-world/"/>
      <url>2020/12/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
