<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>TypeScript-变量声明</title>
      <link href="2020/12/29/TypeScript-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/"/>
      <url>2020/12/29/TypeScript-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<span class="label label-danger">变量声明?</span><p class="text-danger">let和const是JavaScript里相对较新的变量声明方式。 像我们之前提到过的， let在很多方面与var是相似的，但是可以帮助大家避免在JavaScript里常见一些问题。 const是对let的一个增强，它能阻止对一个变量再次赋值。</p><p class="text-danger">因为TypeScript是JavaScript的超集，所以它本身就支持let和const。 下面我们会详细说明这些新的声明方式以及为什么推荐使用它们来代替 var。</p><p class="text-danger">如果你之前使用JavaScript时没有特别在意，那么这节内容会唤起你的回忆。 如果你已经对 var声明的怪异之处了如指掌，那么你可以轻松地略过这节。</p><span class="label label-声明">var</span><p class="text-danger">一直以来我们都是通过var关键字定义JavaScript变量。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  var a = 10;</div><p class="text-danger">大家都能理解，这里定义了一个名为a值为10的变量。</p><p class="text-danger">我们也可以在函数内部定义变量：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f() {</p><p class="text-danger">var message = "Hello, world!";</p><p class="text-danger">return message;</p><p class="text-danger">}</p></div><p class="text-danger">并且我们也可以在其它函数内部访问相同的变量。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f() {</p><p class="text-danger">var a = 10;</p><p class="text-danger">var a = 10;</p><p class="text-danger">return b;</p><p class="text-danger">}</p><p class="text-danger">}</p><p class="text-danger">var g = f();</p><p class="text-danger">g(); // returns 11;</p></div><p class="text-danger">上面的例子里，g可以获取到f函数里定义的a变量。 每当 g被调用时，它都可以访问到f里的a变量。 即使当 g在f已经执行完后才被调用，它仍然可以访问及修改a。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f() {</p><p class="text-danger">var a = 1;</p><p class="text-danger">a = 2;</p><p class="text-danger">var b = g();</p><p class="text-danger">a = 3;</p><p class="text-danger">return b;</p><p class="text-danger">function g() {</p><p class="text-danger">return a;</p><p class="text-danger">}</p><p class="text-danger">}</p><p class="text-danger">f(); // returns 2</p></div><span class="label label-danger">作用域规则</span><p class="text-danger">对于熟悉其它语言的人来说，var声明有些奇怪的作用域规则。 看下面的例子：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f(shouldInitialize: boolean) {</p><p class="text-danger">if (shouldInitialize) {</p><p class="text-danger">var x = 10;</p><p class="text-danger">}</p><p class="text-danger">return x;</p><p class="text-danger">}</p><p class="text-danger">f(true);  // returns '10'</p><p class="text-danger">f(false); // returns 'undefined'</p></div><p class="text-danger">有些读者可能要多看几遍这个例子。 变量 x是定义在*if语句里面*，但是我们却可以在语句的外面访问它。 这是因为 var声明可以在包含它的函数，模块，命名空间或全局作用域内部任何位置被访问（我们后面会详细介绍），包含它的代码块对此没有什么影响。 有些人称此为* var作用域或函数作用域*。 函数参数也使用函数作用域。</p><p class="text-danger">这些作用域规则可能会引发一些错误。 其中之一就是，多次声明同一个变量并不会报错：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function sumMatrix(matrix: number[][]) {</p><p class="text-danger">var sum = 0;</p><p class="text-danger">for (var i = 0; i < matrix.length; i++) {</p><p class="text-danger">var currentRow = matrix[i];</p><p class="text-danger">for (var i = 0; i < currentRow.length; i++) {</p><p class="text-danger">sum += currentRow[i];</p><p class="text-danger">}</p><p class="text-danger">}</p><p class="text-danger">return sum;</p><p class="text-danger">}</p></div><p class="text-danger">这里很容易看出一些问题，里层的for循环会覆盖变量i，因为所有i都引用相同的函数作用域内的变量。 有经验的开发者们很清楚，这些问题可能在代码审查时漏掉，引发无穷的麻烦。</p><span class="label label-danger">捕获变量怪异之处</span><p class="text-danger">快速的猜一下下面的代码会返回什么：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">for (var i = 0; i < 10; i++) {</p><p class="text-danger">setTimeout(function() { console.log(i); }, 100 * i);</p><p class="text-danger">}</p></div><p class="text-danger">介绍一下，setTimeout会在若干毫秒的延时后执行一个函数（等待其它代码执行完毕）。</p><p class="text-danger">好吧，看一下结果：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p><p class="text-danger">10</p></div><p class="text-danger">很多JavaScript程序员对这种行为已经很熟悉了，但如果你很不解，你并不是一个人。 大多数人期望输出结果是这样：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">0</p><p class="text-danger">1</p><p class="text-danger">2</p><p class="text-danger">3</p><p class="text-danger">4</p><p class="text-danger">5</p><p class="text-danger">6</p><p class="text-danger">7</p><p class="text-danger">8</p><p class="text-danger">9</p></div><p class="text-danger">还记得我们上面提到的捕获变量吗？</p><p class="text-danger">我们传给setTimeout的每一个函数表达式实际上都引用了相同作用域里的同一个i。</p><p class="text-danger">让我们花点时间思考一下这是为什么。 setTimeout在若干毫秒后执行一个函数，并且是在for循环结束后。 for循环结束后，i的值为10。 所以当函数被调用的时候，它会打印出 10！</p><p class="text-danger">一个通常的解决方法是使用立即执行的函数表达式（IIFE）来捕获每次迭代时i的值：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">for (var i = 0; i < 10; i++) {</p><p class="text-danger">// capture the current state of 'i'</p><p class="text-danger">// by invoking a function with its current value</p><p class="text-danger">(function(i) {</p><p class="text-danger">setTimeout(function() { console.log(i); }, 100 * i);</p><p class="text-danger">})(i);</p><p class="text-danger">}</p></div><span class="label label-声明">let</span><p class="text-danger">现在你已经知道了var存在一些问题，这恰好说明了为什么用let语句来声明变量。 除了名字不同外， let与var的写法一致。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  let hello = "Hello!";</div><p class="text-danger">主要的区别不在语法上，而是语义，我们接下来会深入研究。</p><span class="label label-danger">块作用域?</span><p class="text-danger">当用let声明一个变量，它使用的是词法作用域或块作用域。 不同于使用 var声明的变量那样可以在包含它们的函数外访问，块作用域变量在包含它们的块或for循环之外是不能访问的。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f(input: boolean) {</p><p class="text-danger">let a = 100;</p><p class="text-danger">if (input) {</p><p class="text-danger">// Still okay to reference 'a'</p><p class="text-danger">let b = a + 1;</p><p class="text-danger">return b;</p><p class="text-danger">}</p><p class="text-danger">// Error: 'b' doesn't exist here</p><p class="text-danger">return b;</p><p class="text-danger">}</p></div><p class="text-danger">这里我们定义了2个变量a和b。 a的作用域是f函数体内，而b的作用域是if语句块里。</p><p class="text-danger">在catch语句里声明的变量也具有同样的作用域规则。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">try {</p><p class="text-danger">throw "oh no!";</p><p class="text-danger">}</p><p class="text-danger">catch (e) {</p><p class="text-danger">console.log("Oh well.");</p><p class="text-danger">}</p><p class="text-danger">// Error: 'e' doesn't exist here</p><p class="text-danger">console.log(e);</p></div><p class="text-danger">拥有块级作用域的变量的另一个特点是，它们不能在被声明之前读或写。 虽然这些变量始终“存在”于它们的作用域里，但在直到声明它的代码之前的区域都属于 暂时性死区。 它只是用来说明我们不能在 let语句之前访问它们，幸运的是TypeScript可以告诉我们这些信息。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">a++; // illegal to use 'a' before it's declared;</p><p class="text-danger">let a;</p></div><p class="text-danger">注意一点，我们仍然可以在一个拥有块作用域变量被声明前获取它。 只是我们不能在变量声明前去调用那个函数。 如果生成代码目标为ES2015，现代的运行时会抛出一个错误；然而，现今TypeScript是不会报错的。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function foo() {</p><p class="text-danger">// okay to capture 'a'</p><p class="text-danger">return a;</p><p class="text-danger">}</p><p class="text-danger">// 不能在'a'被声明前调用'foo'</p><p class="text-danger">// 运行时应该抛出错误</p><p class="text-danger">foo();</p><p class="text-danger">let a;</p></div><p class="text-danger">关于暂时性死区的更多信息，查看这里Mozilla Developer Network.</p><span class="label label-danger">重定义及屏蔽?</span><p class="text-danger">我们提过使用var声明时，它不在乎你声明多少次；你只会得到1个。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f(x) {</p><p class="text-danger">var x;</p><p class="text-danger">var x;</p><p class="text-danger">if (true) {</p><p class="text-danger">var x;</p><p class="text-danger">}</p><p class="text-danger">}</p></div><p class="text-danger">在上面的例子里，所有x的声明实际上都引用一个相同的x，并且这是完全有效的代码。 这经常会成为bug的来源。 好的是， let声明就不会这么宽松了</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let x = 10;</p><p class="text-danger">let x = 20; // 错误，不能在1个作用域里多次声明`x`</p></div><p class="text-danger">并不是要求两个均是块级作用域的声明TypeScript才会给出一个错误的警告。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f(x) {</p><p class="text-danger">let x = 100; // error: interferes with parameter declaration</p><p class="text-danger">}</p><p class="text-danger">function g() {</p><p class="text-danger">let x = 100;</p><p class="text-danger">var x = 100; // error: can't have both declarations of 'x'</p><p class="text-danger">}</p></div><p class="text-danger">并不是说块级作用域变量不能用函数作用域变量来声明。 而是块级作用域变量需要在明显不同的块里声明。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f(condition, x) {</p><p class="text-danger">if (condition) {</p><p class="text-danger">let x = 100;</p><p class="text-danger">return x;</p><p class="text-danger">}</p><p class="text-danger">return x;</p><p class="text-danger">}</p><p class="text-danger">f(false, 0); // returns 0</p><p class="text-danger">f(true, 0);  // returns 100</p></div><p class="text-danger">在一个嵌套作用域里引入一个新名字的行为称做屏蔽。 它是一把双刃剑，它可能会不小心地引入新问题，同时也可能会解决一些错误。 例如，假设我们现在用 let重写之前的sumMatrix函数。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function sumMatrix(matrix: number[][]) {</p><p class="text-danger">let sum = 0;</p><p class="text-danger">for (let i = 0; i < matrix.length; i++) {</p><p class="text-danger">var currentRow = matrix[i];</p><p class="text-danger">for (let i = 0; i < currentRow.length; i++) {</p><p class="text-danger">sum += currentRow[i];</p><p class="text-danger">}</p><p class="text-danger">}</p><p class="text-danger">return sum;</p><p class="text-danger">}</p></div><p class="text-danger">这个版本的循环能得到正确的结果，因为内层循环的i可以屏蔽掉外层循环的i。</p><p class="text-danger">通常来讲应该避免使用屏蔽，因为我们需要写出清晰的代码。 同时也有些场景适合利用它，你需要好好打算一下。</p><span class="label label-danger">块级作用域变量的获取?</span><p class="text-danger">在我们最初谈及获取用var声明的变量时，我们简略地探究了一下在获取到了变量之后它的行为是怎样的。 直观地讲，每次进入一个作用域时，它创建了一个变量的 环境。 就算作用域内代码已经执行完毕，这个环境与其捕获的变量依然存在。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function theCityThatAlwaysSleeps() {</p><p class="text-danger">let getCity;</p><p class="text-danger">if (true) {</p><p class="text-danger">let city = "Seattle";</p><p class="text-danger">getCity = function() {</p><p class="text-danger">return city;</p><p class="text-danger">}</p><p class="text-danger">}</p><p class="text-danger">return getCity();</p><p class="text-danger">}</p></div><p class="text-danger">因为我们已经在city的环境里获取到了city，所以就算if语句执行结束后我们仍然可以访问它。</p><p class="text-danger">回想一下前面setTimeout的例子，我们最后需要使用立即执行的函数表达式来获取每次for循环迭代里的状态。 实际上，我们做的是为获取到的变量创建了一个新的变量环境。 这样做挺痛苦的，但是幸运的是，你不必在TypeScript里这样做了。</p><p class="text-danger">当let声明出现在循环体里时拥有完全不同的行为。 不仅是在循环里引入了一个新的变量环境，而是针对 每次迭代都会创建这样一个新作用域。 这就是我们在使用立即执行的函数表达式时做的事，所以在 setTimeout例子里我们仅使用let声明就可以了。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">for (let i = 0; i < 10 ; i++) {</p><p class="text-danger">setTimeout(function() {console.log(i); }, 100 * i);</p><p class="text-danger">}</p></div><p class="text-danger">会输出与预料一致的结果：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">0</p><p class="text-danger">1</p><p class="text-danger">2</p><p class="text-danger">3</p><p class="text-danger">4</p><p class="text-danger">5</p><p class="text-danger">6</p><p class="text-danger">7</p><p class="text-danger">8</p><p class="text-danger">9</p></div><span class="label label-danger">const声明?</span><p class="text-danger">const 声明是声明变量的另一种方式。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  const numLivesForCat = 9;</div><p class="text-danger">它们与let声明相似，但是就像它的名字所表达的，它们被赋值后不能再改变。 换句话说，它们拥有与 let相同的作用域规则，但是不能对它们重新赋值。</p><p class="text-danger">这很好理解，它们引用的值是不可变的。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">const numLivesForCat = 9;</p><p class="text-danger">const kitty = {</p><p class="text-danger">name: "Aurora",</p><p class="text-danger">numLives: numLivesForCat,</p><p class="text-danger">}</p><p class="text-danger">// Error</p><p class="text-danger">kitty = {</p><p class="text-danger">name: "Danielle",</p><p class="text-danger">numLives: numLivesForCat</p><p class="text-danger">};</p><p class="text-danger">// all "okay"</p><p class="text-danger">kitty.name = "Rory";</p><p class="text-danger">kitty.name = "Kitty";</p><p class="text-danger">kitty.name = "Cat";</p><p class="text-danger">kitty.numLives--;</p></div><p class="text-danger">除非你使用特殊的方法去避免，实际上const变量的内部状态是可修改的。 幸运的是，TypeScript允许你将对象的成员设置成只读的。 接口一章有详细说明。</p><span class="label label-danger">let、vs.、const?</span><p class="text-danger">现在我们有两种作用域相似的声明方式，我们自然会问到底应该使用哪个。 与大多数泛泛的问题一样，答案是：依情况而定。</p><p class="text-danger">使用最小特权原则，所有变量除了你计划去修改的都应该使用const。 基本原则就是如果一个变量不需要对它写入，那么其它使用这些代码的人也不能够写入它们，并且要思考为什么会需要对这些变量重新赋值。 使用 const也可以让我们更容易的推测数据的流动。。</p><p class="text-danger">跟据你的自己判断，如果合适的话，与团队成员商议一下。</p><p class="text-danger">这个手册大部分地方都使用了let声明。</p><span class="label label-danger">解构?</span><p class="text-danger">Another TypeScript已经可以解析其它 ECMAScript 2015 特性了。 完整列表请参见 the article on the Mozilla Developer Network。 本章，我们将给出一个简短的概述。</p><span class="label label-danger">解构数组</span><p class="text-danger">最简单的解构莫过于数组的解构赋值了：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let input = [1, 2];</p><p class="text-danger">let [first, second] = input;</p><p class="text-danger">console.log(first); // outputs 1</p><p class="text-danger">console.log(second); // outputs 2</p></div><p class="text-danger">这创建了2个命名变量 first 和 second。 相当于使用了索引，但更为方便：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">first = input[0];</p><p class="text-danger">second = input[1];</p></div><p class="text-danger">解构作用于已声明的变量会更好：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">// swap variables</p><p class="text-danger">[first, second] = [second, first];</p></div><p class="text-danger">作用于函数参数：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f([first, second]: [number, number]) {</p><p class="text-danger">console.log(first);</p><p class="text-danger">console.log(second);</p><p class="text-danger">}</p><p class="text-danger">f(input);</p></div><p class="text-danger">你可以在数组里使用...语法创建剩余变量：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let [first, ...rest] = [1, 2, 3, 4];</p><p class="text-danger">console.log(first); // outputs 1</p><p class="text-danger">console.log(rest); // outputs [ 2, 3, 4 ]</p></div><p class="text-danger">当然，由于是JavaScript, 你可以忽略你不关心的尾随元素：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let [first] = [1, 2, 3, 4];</p><p class="text-danger">console.log(first); // outputs 1</p></div><p class="text-danger">或其它元素：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let [, second, , fourth] = [1, 2, 3, 4];</p></div><span class="label label-danger">对象解构?</span><p class="text-danger">你也可以解构对象：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let o = {</p><p class="text-danger">a: "foo",</p><p class="text-danger">b: 12,</p><p class="text-danger">c: "bar"</p><p class="text-danger">};</p><p class="text-danger">let { a, b } = o;</p></div><p class="text-danger">这通过 o.a and o.b 创建了 a 和 b 。 注意，如果你不需要 c 你可以忽略它。</p><p class="text-danger">就像数组解构，你可以用没有声明的赋值：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  ({ a, b } = { a: "baz", b: 101 });</div><p class="text-danger">注意，我们需要用括号将它括起来，因为Javascript通常会将以 { 起始的语句解析为一个块。</p><p class="text-danger">你可以在对象里使用...语法创建剩余变量：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let { a, ...passthrough } = o;</p><p class="text-danger">let total = passthrough.b + passthrough.c.length;</p></div><span class="label label-danger">属性重命名</span><p class="text-danger">你也可以给属性以不同的名字：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let { a: newName1, b: newName2 } = o;</p></div><p class="text-danger">这里的语法开始变得混乱。 你可以将 a: newName1 读做 "a 作为 newName1"。 方向是从左到右，好像你写成了以下样子：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let newName1 = o.a;</p><p class="text-danger">let newName2 = o.b;</p></div><p class="text-danger">令人困惑的是，这里的冒号不是指示类型的。 如果你想指定它的类型， 仍然需要在其后写上完整的模式。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let {a, b}: {a: string, b: number} = o;</p></div><span class="label label-danger">默认值</span><p class="text-danger">默认值可以让你在属性为 undefined 时使用缺省值：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function keepWholeObject(wholeObject: { a: string, b?: number }) {</p><p class="text-danger">let { a, b = 1001 } = wholeObject;</p><p class="text-danger">}</p></div><p class="text-danger">现在，即使 b 为 undefined ， keepWholeObject 函数的变量 wholeObject 的属性 a 和 b 都会有值。</p><span class="label label-danger">函数声明</span><p class="text-danger">解构也能用于函数声明。 看以下简单的情况：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">type C = { a: string, b?: number }</p><p class="text-danger">function f({ a, b }: C): void {</p><p class="text-danger">// ...</p><p class="text-danger">}</p></div><p class="text-danger">上面的代码是一个类型推断的例子，将在本手册后文介绍。</p><p class="text-danger">其次，你需要知道在解构属性上给予一个默认或可选的属性用来替换主初始化列表。 要知道 C 的定义有一个 b 可选属性：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function f({ a, b = 0 } = { a: "" }): void {</p><p class="text-danger">// ...</p><p class="text-danger">}</p><p class="text-danger">f({ a: "yes" }); // ok, default b = 0</p><p class="text-danger">f(); // ok, default to {a: ""}, which then defaults b = 0</p><p class="text-danger">f({}); // error, 'a' is required if you supply an argument</p></div><p class="text-danger">要小心使用解构。 从前面的例子可以看出，就算是最简单的解构表达式也是难以理解的。 尤其当存在深层嵌套解构的时候，就算这时没有堆叠在一起的重命名，默认值和类型注解，也是令人难以理解的。 解构表达式要尽量保持小而简单。 你自己也可以直接使用解构将会生成的赋值表达式。</p><span class="label label-danger">展开</span><p class="text-danger">展开操作符正与解构相反。 它允许你将一个数组展开为另一个数组，或将一个对象展开为另一个对象。 例如：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let first = [1, 2];</p><p class="text-danger">let second = [3, 4];</p><p class="text-danger">let bothPlus = [0, ...first, ...second, 5];</p></div><p class="text-danger">这会令bothPlus的值为[0, 1, 2, 3, 4, 5]。 展开操作创建了 first和second的一份浅拷贝。 它们不会被展开操作所改变。</p><p class="text-danger">你还可以展开对象：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };</p><p class="text-danger">let search = { ...defaults, food: "rich" };</p></div><p class="text-danger">search的值为{ food: "rich", price: "$$", ambiance: "noisy" }。 对象的展开比数组的展开要复杂的多。 像数组展开一样，它是从左至右进行处理，但结果仍为对象。 这就意味着出现在展开对象后面的属性会覆盖前面的属性。 因此，如果我们修改上面的例子，在结尾处进行展开的话：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let defaults = { food: "spicy", price: "$$", ambiance: "noisy" };</p><p class="text-danger">let search = { food: "rich", ...defaults };</p></div><p class="text-danger">那么，defaults里的food属性会重写food: "rich"，在这里这并不是我们想要的结果。</p><p class="text-danger">对象展开还有其它一些意想不到的限制。 首先，它仅包含对象 自身的可枚举属性。 大体上是说当你展开一个对象实例时，你会丢失其方法：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">class C {</p><p class="text-danger">p = 12;</p><p class="text-danger">m() {</p><p class="text-danger">}</p><p class="text-danger">}</p><p class="text-danger">let c = new C();</p><p class="text-danger">let clone = { ...c };</p><p class="text-danger">clone.p; // ok</p><p class="text-danger">clone.m(); // error!</p></div><p class="text-danger">其次，TypeScript编译器不允许展开泛型函数上的类型参数。 这个特性会在TypeScript的未来版本中考虑实现。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript总结</title>
      <link href="2020/12/29/TypeScript%E6%80%BB%E7%BB%93/"/>
      <url>2020/12/29/TypeScript%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<span class="label label-danger">基础类型?</span><p class="text-danger">为了让程序有价值，我们需要能够处理最简单的数据单元：数字，字符串，结构体，布尔值等。 TypeScript支持与JavaScript几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><span class="label label-danger">布尔值</span><p class="text-danger">最基本的数据类型就是简单的true/false值，在JavaScript和TypeScript里叫做boolean（其它语言中也一样）。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  let isDone: boolean = false;</div><span class="label label-danger">数字</span><p class="text-danger">和JavaScript一样，TypeScript里的所有数字都是浮点数。 这些浮点数的类型是 number。 除了支持十进制和十六进制字面量，TypeScript还支持ECMAScript 2015中引入的二进制和八进制字面量。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let decLiteral: number = 6;</p><p class="text-danger">let hexLiteral: number = 0xf00d;</p><p class="text-danger">let binaryLiteral: number = 0b1010;</p><p class="text-danger">let octalLiteral: number = 0o744;</p></div><span class="label label-danger">字符串</span><p class="text-danger">JavaScript程序的另一项基本操作是处理网页或服务器端的文本数据。 像其它语言里一样，我们使用 string表示文本数据类型。 和JavaScript一样，可以使用双引号（ "）或单引号（'）表示字符串。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let name: string = "bob";</p><p class="text-danger">name = "smith";</p></div><p class="text-danger">你还可以使用模版字符串，它可以定义多行文本和内嵌表达式。 这种字符串是被反引号包围（ `），并且以${ expr }这种形式嵌入表达式</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let name: string = `Gene`;</p><p class="text-danger">let age: number = 37;</p><p class="text-danger">let sentence: string = `Hello, my name is ${ name }.I'll be ${ age + 1 } years old next month.`;</p></div><p class="text-danger">这与下面定义sentence的方式效果相同：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let sentence: string = "Hello, my name is " + name + ".\n\n" +    "I'll be " + (age + 1) + " years old next month.";</p></div><span class="label label-danger">数组</span><p class="text-danger">TypeScript像JavaScript一样可以操作数组元素。 有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let list: number[] = [1, 2, 3];</p></div><p class="text-danger">第二种方式是使用数组泛型，Array<元素类型>：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let list: Array<number> = [1, 2, 3];</p></div><span class="label label-Tuple">元组</span><p class="text-danger">元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">// Declare a tuple type</p><p class="text-danger">let x: [string, number];</p><p class="text-danger">// Initialize it</p><p class="text-danger">x = ['hello', 10]; // OK</p><p class="text-danger">// Initialize it incorrectly</p><p class="text-danger">x = [10, 'hello']; // Error</p></div><p class="text-danger">当访问一个已知索引的元素，会得到正确的类型：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">console.log(x[0].substr(1)); // OK</p><p class="text-danger">console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'</p></div><p class="text-danger">当访问一个越界的元素，会使用联合类型替代：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型</p><p class="text-danger">console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toString</p><p class="text-danger">x[6] = true; // Error, 布尔不是(string | number)类型</p></div><p class="text-danger">联合类型是高级主题，我们会在以后的章节里讨论它。</p><span class="label label-danger">枚举</span><p class="text-danger">enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">enum Color {Red, Green, Blue}</p><p class="text-danger">let c: Color = Color.Green;</p></div><p class="text-danger">默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">enum Color {Red = 1, Green, Blue}</p><p class="text-danger">let c: Color = Color.Green;</p></div><p class="text-danger">或者，全部都采用手动赋值：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">enum Color {Red = 1, Green = 2, Blue = 4}</p><p class="text-danger">let c: Color = Color.Green;</p></div><p class="text-danger">枚举类型提供的一个便利是你可以由枚举的值得到它的名字。 例如，我们知道数值为2，但是不确定它映射到Color里的哪个名字，我们可以查找相应的名字：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">enum Color {Red = 1, Green, Blue}</p><p class="text-danger">let colorName: string = Color[2];</p><p class="text-danger">console.log(colorName);  // 显示'Green'因为上面代码里它的值是2</p></div><span class="label label-danger">Any</span><p class="text-danger">有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let notSure: any = 4;</p><p class="text-danger">notSure = "maybe a string instead";</p><p class="text-danger">notSure = false; // okay, definitely a boolean</p></div><p class="text-danger">在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let notSure: any = 4;</p><p class="text-danger">notSure.ifItExists(); // okay, ifItExists might exist at runtime</p><p class="text-danger">notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)</p><p class="text-danger">let prettySure: Object = 4;</p><p class="text-danger">prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.</p></div><p class="text-danger">当你只知道一部分数据的类型时，any类型也是有用的。 比如，你有一个数组，它包含了不同的类型的数据：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let list: any[] = [1, true, "free"];</p><p class="text-danger">list[1] = 100;</p></div><span class="label label-danger">Void</span><p class="text-danger">某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">function warnUser(): void {</p><p class="text-danger">console.log("This is my warning message");</p><p class="text-danger">}</p></div><p class="text-danger">声明一个void类型的变量没有什么大用，因为你只能为它赋予undefined和null：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let unusable: void = undefined;</p></div><span class="label label-danger">Null和Undefined</span><p class="text-danger">TypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。 和 void相似，它们的本身的类型用处不是很大：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">// Not much else we can assign to these variables!</p><p class="text-danger">let u: undefined = undefined;</p><p class="text-danger">let n: null = null;</p></div><p class="text-danger">默认情况下null和undefined是所有类型的子类型。 就是说你可以把 null和undefined赋值给number类型的变量。</p><p class="text-danger">然而，当你指定了--strictNullChecks标记，null和undefined只能赋值给void和它们各自。 这能避免 很多常见的问题。 也许在某处你想传入一个 string或null或undefined，你可以使用联合类型string | null | undefined。 再次说明，稍后我们会介绍联合类型。</p><span class="label label-danger">Never</span><p class="text-danger">never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。</p><p class="text-danger">never类型是任何类型的子类型，也可以赋值给任何类型；然而，没有类型是never的子类型或可以赋值给never类型（除了never本身之外）。 即使 any也不可以赋值给never。</p><p class="text-danger">下面是一些返回never类型的函数：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">// 返回never的函数必须存在无法达到的终点</p><p class="text-danger">function error(message: string): never {</p><p class="text-danger">throw new Error(message);</p><p class="text-danger">}</p><p class="text-danger">// 推断的返回值类型为never</p><p class="text-danger">function fail() {</p><p class="text-danger">return error("Something failed");</p><p class="text-danger">}</p><p class="text-danger">// 返回never的函数必须存在无法达到的终点</p><p class="text-danger">function infiniteLoop(): never {</p><p class="text-danger">while (true) {</p><p class="text-danger">}</p><p class="text-danger">}</p></div><span class="label label-danger">Object</span><p class="text-danger">object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。使用object类型，就可以更好的表示像Object.create这样的API。例如：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">declare function create(o: object | null): void;</p><p class="text-danger">create({ prop: 0 }); // OK</p><p class="text-danger">create(null); // OK</p><p class="text-danger">create(42); // Error</p><p class="text-danger">create("string"); // Error</p><p class="text-danger">create(false); // Error</p><p class="text-danger">create(undefined); // Error</p></div><span class="label label-danger">类型断言</span><p class="text-danger">有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。</p><p class="text-danger">通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。</p><p class="text-danger">类型断言有两种形式。 其一是“尖括号”语法：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let someValue: any = "this is a string";</p><p class="text-danger">let strLength: number = (<string>someValue).length;</p></div><p class="text-danger">另一个为as语法：</p><div class="alert alert-success"><i class="fa fa-lightbulb-o"></i>  <p class="text-danger">let someValue: any = "this is a string";</p><p class="text-danger">let strLength: number = (someValue as string).length;</p></div><p class="text-danger">两种形式是等价的。 至于使用哪个大多数情况下是凭个人喜好；然而，当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。</p><span class="label label-danger">关于let</span><p class="text-danger">你可能已经注意到了，我们使用let关键字来代替大家所熟悉的JavaScript关键字var。 let关键字是JavaScript的一个新概念，TypeScript实现了它。 我们会在以后详细介绍它，很多常见的问题都可以通过使用 let来解决，所以尽可能地使用let来代替var吧。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>class总结</title>
      <link href="2020/12/28/class%E6%80%BB%E7%BB%93/"/>
      <url>2020/12/28/class%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>什么是class？、<br>他是怎么来的？<br>JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子。</p><p>function Point(x, y) {<br>  this.x = x;<br>  this.y = y;<br>}<br>Point.prototype.toString = function () {<br>  return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>};<br>var p = new Point(1, 2);<br>这种写法跟传统的面向对象语言比如 C++ 和 Java差异很是大的</p><p>上面的代码用es6改写的class写法如下<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }</p><p>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }<br>}</p><p>上面代码定义了一个“类”，可以看到里面有一个constructor()方法，这就是构造方法，而this关键字则代表实例对象。这种新的 Class 写法，本质上与本章开头的 ES5 的构造函数Point是一致的。</p><p>Point类除了构造方法，还定义了一个toString()方法。注意，定义toString()方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法与方法之间不需要逗号分隔，加了会报错。</p><p>ES6 的类，完全可以看作构造函数的另一种写法。<br>class Point {<br>  // …<br>}<br>typeof Point // “function”<br>Point === Point.prototype.constructor // true<br>类的数据类型就是函数，类本身就指向构造函数。使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。<br>class Bar {<br>  doStuff() {<br>    console.log(‘stuff’);<br>  }<br>}<br>const b = new Bar();<br>b.doStuff() // “stuff”<br>构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。<br>class Point {<br>  constructor() {<br>    // …<br>  }</p><p>  toString() {<br>    // …<br>  }</p><p>  toValue() {<br>    // …<br>  }<br>}<br>// 等同于<br>Point.prototype = {<br>  constructor() {},<br>  toString() {},<br>  toValue() {},<br>};</p><p>因此，在类的实例上面调用方法，其实就是调用原型上的方法。<br>class B {}<br>const b = new B();</p><p>b.constructor === B.prototype.constructor // true<br>b是B类的实例，它的constructor()方法就是B类原型的constructor()方法。</p><p>由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign()方法可以很方便地一次向类添加多个方法。<br>class Point {<br>  constructor(){<br>    // …<br>  }<br>}</p><p>Object.assign(Point.prototype, {<br>  toString(){},<br>  toValue(){}<br>});<br>prototype对象的constructor()属性，直接指向“类”的本身，这与 ES5 的行为是一致的。<br>Point.prototype.constructor === Point // true</p><p>constructor 方法<br>constructor()方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor()方法，如果没有显式定义，一个空的constructor()方法会被默认添加。</p><p>class Point {<br>}</p><p>// 等同于<br>class Point {<br>  constructor() {}<br>}</p><p>类的实例<br>生成类的实例的写法，与 ES5 完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p><p>class Point {<br>  // …<br>}</p><p>// 报错<br>var point = Point(2, 3);</p><p>// 正确<br>var point = new Point(2, 3);</p><p>与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p><p>//定义类<br>class Point {<br>  constructor(x, y) {<br>    this.x = x;<br>    this.y = y;<br>  }<br>  toString() {<br>    return ‘(‘ + this.x + ‘, ‘ + this.y + ‘)’;<br>  }<br>}<br>var point = new Point(2, 3);<br>point.toString() // (2, 3)<br>point.hasOwnProperty(‘x’) // true<br>point.hasOwnProperty(‘y’) // true<br>point.hasOwnProperty(‘toString’) // false<br>point.<strong>proto</strong>.hasOwnProperty(‘toString’) // true</p><p>与 ES5 一样，类的所有实例共享一个原型对象。<br>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p><p>p1.<strong>proto</strong> === p2.<strong>proto</strong><br>//true<br>上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。</p><p>这也意味着，可以通过实例的__proto__属性为“类”添加方法。</p><p><strong>proto</strong> 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性。</p><p>var p1 = new Point(2,3);<br>var p2 = new Point(3,2);</p><p>p1.<strong>proto</strong>.printName = function () { return ‘Oops’ };</p><p>p1.printName() // “Oops”<br>p2.printName() // “Oops”</p><p>var p3 = new Point(4,2);<br>p3.printName() // “Oops”<br>上面代码在p1的原型上添加了一个printName()方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变“类”的原始定义，影响到所有实例。<br>取值函数（getter）和存值函数（setter）<br>与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><p>class MyClass {<br>  constructor() {<br>    // …<br>  }<br>  get prop() {<br>    return ‘getter’;<br>  }<br>  set prop(value) {<br>    console.log(‘setter: ‘+value);<br>  }<br>}</p><p>let inst = new MyClass();</p><p>inst.prop = 123;<br>// setter: 123</p><p>inst.prop<br>// ‘getter’</p><p>属性表达式<br>类的属性名，可以采用表达式。</p><p>let methodName = ‘getArea’;</p><p>class Square {<br>  constructor(length) {<br>    // …<br>  }</p><p>  <a href="">methodName</a> {<br>    // …<br>  }<br>}<br>Square类的方法名getArea，是从表达式得到的。</p><p>Class 表达式<br>与函数一样，类也可以使用表达式的形式定义。</p><p>const MyClass = class Me {<br>  getClassName() {<br>    return Me.name;<br>  }<br>};<br>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是Me，但是Me只在 Class 的内部可用，指代当前类。在 Class 外部，这个类只能用MyClass引用。</p><p>采用 Class 表达式，可以写出立即执行的 Class。</p><p>let person = new class {<br>  constructor(name) {<br>    this.name = name;<br>  }</p><p>  sayName() {<br>    console.log(this.name);<br>  }<br>}(‘张三’);</p><p>person.sayName(); // “张三” person是一个立即执行的类的实例</p><p>静态方法<br>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p><p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p><p>Foo.classMethod() // ‘hello’</p><p>var foo = new Foo();<br>foo.classMethod()<br>// TypeError: foo.classMethod is not a function<br>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p><p>注意，如果静态方法包含this关键字，这个this指的是类，而不是实例。</p><p>class Foo {<br>  static bar() {<br>    this.baz();<br>  }<br>  static baz() {<br>    console.log(‘hello’);<br>  }<br>  baz() {<br>    console.log(‘world’);<br>  }<br>}</p><p>Foo.bar() // hello<br>上面代码中，静态方法bar调用了this.baz，这里的this指的是Foo类，而不是Foo的实例，等同于调用Foo.baz。另外，从这个例子还可以看出，静态方法可以与非静态方法重名。</p><p>父类的静态方法，可以被子类继承。</p><p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p><p>class Bar extends Foo {<br>}</p><p>Bar.classMethod() // ‘hello’<br>上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。</p><p>静态方法也是可以从super对象上调用的。</p><p>class Foo {<br>  static classMethod() {<br>    return ‘hello’;<br>  }<br>}</p><p>class Bar extends Foo {<br>  static classMethod() {<br>    return super.classMethod() + ‘, too’;<br>  }<br>}</p><p>Bar.classMethod() // “hello, too”<br>实例属性的新写法<br>实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层。</p><p>class IncreasingCounter {<br>  constructor() {<br>    this._count = 0;<br>  }<br>  get value() {<br>    console.log(‘Getting the current value!’);<br>    return this._count;<br>  }<br>  increment() {<br>    this._count++;<br>  }<br>}<br>上面代码中，实例属性this._count定义在constructor()方法里面。另一种写法是，这个属性也可以定义在类的最顶层，其他都不变。</p><p>class IncreasingCounter {<br>  _count = 0;<br>  get value() {<br>    console.log(‘Getting the current value!’);<br>    return this._count;<br>  }<br>  increment() {<br>    this._count++;<br>  }<br>}<br>上面代码中，实例属性_count与取值函数value()和increment()方法，处于同一个层级。这时，不需要在实例属性前面加上this。</p><p>这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性。</p><p>class foo {<br>  bar = ‘hello’;<br>  baz = ‘world’;</p><p>  constructor() {<br>    // …<br>  }<br>}<br>上面的代码，一眼就能看出，foo类有两个实例属性，一目了然。另外，写起来也比较简洁。</p><p>静态属性<br>静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性。</p><p>class Foo {<br>}</p><p>Foo.prop = 1;<br>Foo.prop // 1<br>上面的写法为Foo类定义了一个静态属性prop。</p><p>目前，只有这种写法可行，因为 ES6 明确规定，Class 内部只有静态方法，没有静态属性。现在有一个提案提供了类的静态属性，写法是在实例属性的前面，加上static关键字。</p><p>class MyClass {<br>  static myStaticProp = 42;</p><p>  constructor() {<br>    console.log(MyClass.myStaticProp); // 42<br>  }<br>}<br>这个新写法大大方便了静态属性的表达。</p><p>// 老写法<br>class Foo {<br>  // …<br>}<br>Foo.prop = 1;</p><p>// 新写法<br>class Foo {<br>  static prop = 1;<br>}<br>上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hooks总结</title>
      <link href="2020/12/25/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>2020/12/25/%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>大部分 React 类组件可以保存状态，而函数组件不能？ 并且类组件具有生命周期，而函数组件却不能？<br>React 早期版本，类组件可以通过继承PureComponent来优化一些不必要的渲染，相对于函数组件，React 官网没有提供对应的方法来缓存函数组件以减少一些不必要的渲染，直接 16.6 出来的 React.memo函数。</p><p>React 16.8 新出来的Hook可以让React 函数组件具有状态，并提供类似 componentDidMount和componentDidUpdate,componentunMount等生命周期方法。</p><p>类被会替代吗？<br>Hooks不会替换类，它们只是一个你可以使用的新工具。React 团队表示他们没有计划在React中弃用类，所以如果你想继续使用它们，可以继续用。<br>基础的Hook目前有三个先介绍一下</p><p>1:useState 2:useEffect 3:useContext</p><p>useState<br>语法 const [state, setState] = useState(initialState);<br>返回一个state，以及更新state的函数 Hook 简介章节中使用下面的例子介绍了 Hook：</p><p>import React, { useState } from ‘react’;</p><p>function Example() {<br>  // 声明一个叫 “count” 的 state 变量<br>  const [count, setCount] = useState(0);<br>  return (<br>    <div><br>      <p>{count}</p><br>      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;<br>        改变count值+=1<br>      </button><br>    </div><br>  );<br>}</p><p>这段代码的大部分看起来像一分钟前写的普通函数组件，除了useState。<br>useState是一个hook。 它的名字以“use”开头（这是Hooks的规则之一 - 它们的名字必须以“use”开头）。<br>useState hook 的参数是 state 的初始值，返回一个包含两个元素的数组:当前state和一个用于更改state 的函数。<br>由于Hook以某种特殊方式创建这些状态，并且在函数组件内也没有像setState函数来更改状态，因此 Hook 需要一个函数来更新每个状态。 所以 useState 返回是一对对应关系：一个值，一个更新该值函数。 当然，值可以是任何东西 - 任何JS类型 - 数字，布尔值，对象，数组等。<br>等价的 class 示例</p><p>class Example extends React.Component {<br>  constructor(props) {<br>    super(props);<br>    this.state = {<br>      count: 0<br>    };<br>  }<br>  render() {<br>    return (<br>      <div><br>        <p>{this.state.count}</p><br>        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;<br>        改变count值+=1<br>        </button><br>      </div><br>    );<br>  }<br>}<br>useEffect<br>useEffect(didUpdate);<br>该 Hook 接收一个包含命令式、且可能有副作用代码的函数。</p><p>在函数组件主体内（这里指在 React 渲染阶段）改变 DOM、添加订阅、设置定时器、记录日志以及执行其他包含副作用的操作都是不被允许的，因为这可能会产生莫名其妙的 bug 并破坏 UI 的一致性。</p><p>使用 useEffect 完成副作用操作。赋值给 useEffect 的函数会在组件渲染到屏幕之后执行。你可以把 effect 看作从 React 的纯函数式世界通往命令式世界的逃生通道。</p><p>默认情况下，effect 将在每轮渲染结束后执行，但你可以选择让它 在只有某些值改变的时候 才执行。</p><p>清除 effect<br>通常，组件卸载时需要清除 effect 创建的诸如订阅或计时器 ID 等资源。要实现这一点，useEffect 函数需返回一个清除函数。以下就是一个创建订阅的例子：</p><p>useEffect(() =&gt; {<br>  const subscription = props.source.subscribe();<br>  return () =&gt; {<br>    // 清除订阅<br>    subscription.unsubscribe();<br>  };<br>});<br>为防止内存泄漏，清除函数会在组件卸载前执行。另外，如果组件多次渲染（通常如此），则在执行下一个 effect 之前，上一个 effect 就已被清除。在上述示例中，意味着组件的每一次更新都会创建新的订阅。若想避免每次更新都触发 effect 的执行，请参阅下一小节。<br>effect 的执行时机<br>与 componentDidMount、componentDidUpdate 不同的是，在浏览器完成布局与绘制之后，传给 useEffect 的函数会延迟调用。这使得它适用于许多常见的副作用场景，比如设置订阅和事件处理等情况，因此不应在函数中执行阻塞浏览器更新屏幕的操作。</p><p>然而，并非所有 effect 都可以被延迟执行。例如，在浏览器执行下一次绘制前，用户可见的 DOM 变更就必须同步执行，这样用户才不会感觉到视觉上的不一致。（概念上类似于被动监听事件和主动监听事件的区别。）React 为此提供了一个额外的 useLayoutEffect Hook 来处理这类 effect。它和 useEffect 的结构相同，区别只是调用时机不同。</p><p>虽然 useEffect 会在浏览器绘制后延迟执行，但会保证在任何新的渲染前执行。React 将在组件更新前刷新上一轮渲染的 effect。</p><p>effect 的条件执行<br>默认情况下，effect 会在每轮组件渲染完成后执行。这样的话，一旦 effect 的依赖发生变化，它就会被重新创建。</p><p>然而，在某些场景下这么做可能会矫枉过正。比如，在上一章节的订阅示例中，我们不需要在每次组件更新时都创建新的订阅，而是仅需要在 source prop 改变时重新创建。</p><p>要实现这一点，可以给 useEffect 传递第二个参数，它是 effect 所依赖的值数组。更新后的示例如下：</p><p>useEffect(<br>  () =&gt; {<br>    const subscription = props.source.subscribe();<br>    return () =&gt; {<br>      subscription.unsubscribe();<br>    };<br>  },<br>  [props.source],<br>);<br>此时，只有当 props.source 改变后才会重新创建订阅。</p><p>依赖项数组不会作为参数传给 effect 函数。虽然从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中。未来编译器会更加智能，届时自动创建数组将成为可能。</p><p>useContext<br>const value = useContext(MyContext);<br>接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。当前的 context 值由上层组件中距离当前组件最近的 &lt;MyContext.Provider&gt; 的 value prop 决定。</p><p>当组件上层最近的 &lt;MyContext.Provider&gt; 更新时，该 Hook 会触发重渲染，并使用最新传递给 MyContext provider 的 context value 值。即使祖先使用 React.memo 或 shouldComponentUpdate，也会在组件本身使用 useContext 时重新渲染。</p><p>别忘记 useContext 的参数必须是 context 对象本身：</p><p>正确： useContext(MyContext)<br>错误： useContext(MyContext.Consumer)<br>错误： useContext(MyContext.Provider)<br>调用了 useContext 的组件总会在 context 值变化时重新渲染。如果重渲染组件的开销较大，你可以 通过使用 memoization 来优化。</p><p>useReducer<br>const [state, dispatch] = useReducer(reducer, initialArg, init);<br>useState 的替代方案。它接收一个形如 (state, action) =&gt; newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法。（如果你熟悉 Redux 的话，就已经知道它如何工作了。）</p><p>在某些场景下，useReducer 会比 useState 更适用，例如 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖于之前的 state 等。并且，使用 useReducer 还能给那些会触发深更新的组件做性能优化，因为你可以向子组件传递 dispatch 而不是回调函数 。<br>指定初始 state<br>有两种不同初始化 useReducer state 的方式，你可以根据使用场景选择其中的一种。将初始 state 作为第二个参数传入 useReducer 是最简单的方法：<br>惰性初始化<br>你可以选择惰性地创建初始 state。为此，需要将 init 函数作为 useReducer 的第三个参数传入，这样初始 state 将被设置为 init(initialArg)。</p><p>这么做可以将用于计算 state 的逻辑提取到 reducer 外部，这也为将来对重置 state 的 action 做处理提供了便利：<br>跳过 dispatch<br>如果 Reducer Hook 的返回值与当前 state 相同，React 将跳过子组件的渲染及副作用的执行。（React 使用 Object.is 比较算法 来比较 state。）</p><p>需要注意的是，React 可能仍需要在跳过渲染前再次渲染该组件。不过由于 React 不会对组件树的“深层”节点进行不必要的渲染，所以大可不必担心。如果你在渲染期间执行了高开销的计算，则可以使用 useMemo 来进行优化。</p><p>useCallback<br>返回一个 memoized 回调函数。</p><p>把内联回调函数及依赖项数组作为参数传入 useCallback，它将返回该回调函数的 memoized 版本，该回调函数仅在某个依赖项改变时才会更新。当你把回调函数传递给经过优化的并使用引用相等性去避免非必要渲染（例如 shouldComponentUpdate）的子组件时，它将非常有用。<br>useMemo<br>返回一个 memoized 值。</p><p>把“创建”函数和依赖项数组作为参数传入 useMemo，它仅会在某个依赖项改变时才重新计算 memoized 值。这种优化有助于避免在每次渲染时都进行高开销的计算。</p><p>记住，传入 useMemo 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 useEffect 的适用范畴，而不是 useMemo。</p><p>如果没有提供依赖项数组，useMemo 在每次渲染时都会计算新的值。</p><p>你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。将来，React 可能会选择“遗忘”以前的一些 memoized 值，并在下次渲染时重新计算它们，比如为离屏组件释放内存。先编写在没有 useMemo 的情况下也可以执行的代码 —— 之后再在你的代码中添加 useMemo，以达到优化性能的目的。<br>useRef<br>const refContainer = useRef(initialValue);<br>useRef 返回一个可变的 ref 对象，其 .current 属性被初始化为传入的参数（initialValue）。返回的 ref 对象在组件的整个生命周期内保持不变。</p><p>一个常见的用例便是命令式地访问子组件：</p><p>function TextInputWithFocusButton() {<br>  const inputEl = useRef(null);<br>  const onButtonClick = () =&gt; {<br>    // <code>current</code> 指向已挂载到 DOM 上的文本输入元素<br>    inputEl.current.focus();<br>  };<br>  return (<br>    &lt;&gt;<br>      <input ref={inputEl} type="text" /><br>      <button onClick={onButtonClick}>Focus the input</button><br>    &lt;/&gt;<br>  );<br>}<br>本质上，useRef 就像是可以在其 .current 属性中保存一个可变值的“盒子”。</p><p>你应该熟悉 ref 这一种访问 DOM 的主要方式。如果你将 ref 对象以 <div ref={myRef} /> 形式传入组件，则无论该节点如何改变，React 都会将 ref 对象的 .current 属性设置为相应的 DOM 节点。</p><p>然而，useRef() 比 ref 属性更有用。它可以很方便地保存任何可变值，其类似于在 class 中使用实例字段的方式。</p><p>这是因为它创建的是一个普通 Javascript 对象。而 useRef() 和自建一个 {current: …} 对象的唯一区别是，useRef 会在每次渲染时返回同一个 ref 对象。</p><p>请记住，当 ref 对象内容发生变化时，useRef 并不会通知你。变更 .current 属性不会引发组件重新渲染。如果想要在 React 绑定或解绑 DOM 节点的 ref 时运行某些代码，则需要使用回调 ref 来实现。</p><p>useImperativeHandle<br>useImperativeHandle(ref, createHandle, [deps])<br>useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。useImperativeHandle 应当与 forwardRef 一起使用：</p><p>function FancyInput(props, ref) {<br>  const inputRef = useRef();<br>  useImperativeHandle(ref, () =&gt; ({<br>    focus: () =&gt; {<br>      inputRef.current.focus();<br>    }<br>  }));<br>  return &lt;input ref={inputRef} … /&gt;;<br>}<br>FancyInput = forwardRef(FancyInput);<br>在本例中，渲染 <FancyInput ref={inputRef} /> 的父组件可以调用 inputRef.current.focus()。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="2020/12/25/test/"/>
      <url>2020/12/25/test/</url>
      
        <content type="html"><![CDATA[<p>hexo clean<br>hexo generate<br>hexo deploy</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/25/hello-world/"/>
      <url>2020/12/25/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
